#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const json_bigint_1 = __importDefault(require("json-bigint"));
const yargs_1 = __importDefault(require("yargs"));
const fs_1 = __importDefault(require("fs"));
const src_1 = require("../src");
const argv = yargs_1.default.command('$0 <input>', 'convert llrp json to bin', yargs => {
    yargs.positional('input', {
        describe: 'path to llrp JSON file',
        type: 'string'
    }).demandOption(['input']);
})
    .option('output', {
    alias: 'o',
    description: 'path to output binary file',
    type: 'string'
})
    .option('iso8601fp', {
    alias: 'i',
    description: 'enables datetime microsecond full precision (default: true)',
    type: 'boolean',
    default: true
})
    .help().alias('help', 'h')
    .argv;
(async () => {
    let json = fs_1.default.readFileSync(argv.input, 'utf-8');
    let obj = json_bigint_1.default.parse(json);
    let result = [];
    if (Array.isArray(obj)) {
        for (let i in obj) {
            let m = obj[i];
            let msg = new src_1.LLRPMessage(m);
            let buf = msg.encode().getBuffer();
            result.push(buf);
        }
    }
    else {
        let msg = new src_1.LLRPMessage(obj);
        let buf = msg.encode().getBuffer();
        result.push(buf);
    }
    if (argv.output) {
        fs_1.default.writeFileSync(argv.output, Buffer.concat(result));
    }
    else {
        process.stdout.write(Buffer.concat(result));
    }
})().catch(e => console.error(e));
//# sourceMappingURL=json2llrp.js.map