"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LLRPTypedNet = void 0;
const message_1 = require("../proxy/message");
const base_1 = require("./base");
const class_registry_1 = require("../registry/class-registry");
class LLRPTypedNet extends base_1.LLRPNet {
    constructor() {
        super(...arguments);
        this.CR = class_registry_1.LLRPClassRegistry.getInstance();
        this.listenerMap = new Map;
    }
    static ofDef(Def) {
        return class LLRPTypedNet extends this {
            constructor() {
                super(...arguments);
                this.Def = Def;
                this.CR = class_registry_1.LLRPClassRegistry.getInstance(Def);
            }
            async send(m) {
                return super.send(m);
            }
            async recv(timeout) {
                const proxy = await super.recv(timeout);
                const LLRPTypedMessage = this.CR.getCoreMessageClass(proxy.getName());
                // unfortunately, we need to cast as any to avoid the excessively deep type matching in the class registry (when using a typed constructor instead of the proxy)
                return new LLRPTypedMessage(proxy.origin);
            }
            async transact(m, timeout) {
                const proxy = await super.transact(m, timeout);
                const LLRPTypedMessage = this.CR.getCoreMessageClass(proxy.getName());
                return new LLRPTypedMessage(proxy.origin);
            }
        };
    }
    getNewListener(event, listener) {
        const newListener = (m) => {
            if (base_1.LLRPNetNativeEvents.includes(event)) {
                listener(m);
            }
            else {
                const CR = class_registry_1.LLRPClassRegistry.getInstance(this.Def, event);
                const LLRPTypedMessage = CR.getCoreMessageClass(event);
                let newM;
                if (!LLRPTypedMessage) {
                    // no typed class found? go with the generic proxy
                    newM = new message_1.LLRPProxyMessage(m.origin);
                }
                else
                    newM = new LLRPTypedMessage(m.origin);
                listener(newM);
            }
        };
        this.listenerMap.set(listener, [event, newListener]);
        return newListener;
    }
    on(event, listener) {
        const newListener = this.getNewListener(event, listener);
        this._ee.on(event, newListener);
        return this;
    }
    off(event, listener) {
        const pair = this.listenerMap.get(listener);
        if (!pair)
            return this;
        const [e, newListener] = pair;
        if (newListener)
            this._ee.off(event, newListener);
        this.listenerMap.delete(listener);
        return this;
    }
    once(event, listener) {
        const newListener = this.getNewListener(event, listener);
        this._ee.once(event, newListener);
        return this;
    }
    removeListener(event, listener) {
        const pair = this.listenerMap.get(listener);
        if (!pair)
            return this;
        const [e, newListener] = pair;
        if (newListener)
            this._ee.removeListener(event, newListener);
        this.listenerMap.delete(listener);
        return this;
    }
    removeAllListeners(event) {
        for (let pair of this.listenerMap) {
            const [listener, [e, newListener]] = pair;
            if (!event || (event === e))
                this.removeListener(e, listener);
        }
        return this;
    }
}
exports.LLRPTypedNet = LLRPTypedNet;
//# sourceMappingURL=typed.js.map