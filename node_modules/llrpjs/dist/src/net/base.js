"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LLRPNet = exports.LLRPNetNativeEvents = void 0;
const events_1 = __importDefault(require("events"));
const error_1 = require("../base/error");
const message_1 = require("../proxy/message");
const scanner_1 = require("../element/scanner");
const lock_1 = require("./lock");
const timer_1 = require("./timer");
exports.LLRPNetNativeEvents = [
    "connection",
    "close",
    "connect",
    "disconnect",
    "message",
    "error"
];
class LLRPNet {
    constructor(options) {
        this._ee = new events_1.default;
        this._scanner = new scanner_1.LLRPScanner;
        this._lock = new lock_1.Lock;
        this._send = this.invalidSend;
        this._recv = this.invalidRecv;
        options = { host: "localhost", port: 5084, ...options };
        this.options = options;
    }
    async invalidSend(m) {
        return new Promise((r, j) => j(new error_1.LLRPError("ERR_LLRP_READER_OFFLINE", `Cannot send data`)));
    }
    async invalidRecv() {
        return new Promise((r, j) => j(new error_1.LLRPError("ERR_LLRP_READER_OFFLINE", `Cannot receive data`)));
    }
    async validSend(m) {
        return new Promise((resolve, reject) => {
            this._tcp.write.call(this._tcp, m.encode().getBuffer(), err => {
                if (err)
                    reject(err);
                resolve();
            });
        });
    }
    async validRecv() {
        return new Promise(resolve => this._ee.once("message", msg => {
            resolve(msg);
        }));
    }
    ;
    async onData(data) {
        try {
            this._scanner.addBuffer.call(this._scanner, data);
            const msgBuf = this._scanner.getNext.call(this._scanner);
            if (msgBuf) {
                const msg = new message_1.LLRPProxyMessage(msgBuf).decode();
                this._ee.emit("message", msg);
                this._ee.emit(msg.getName(), msg);
            }
        }
        catch (e) {
            if (e instanceof error_1.LLRPError)
                this._ee.emit("error", e);
            else
                throw e;
        }
    }
    async onSocketClose() {
        this._tcp.removeAllListeners();
        this._send = this.invalidSend.bind(this);
        this._recv = this.invalidRecv.bind(this);
        this._tcp = null;
        this._ee.emit("disconnect");
    }
    async initializeServer(server) {
        this._server = server;
        server.maxConnections = 1;
        server.on("connection", async (socket) => {
            this._tcp = socket;
            this._send = this.validSend.bind(this);
            this._recv = this.validRecv.bind(this);
            socket.on("error", err => {
                this._ee.emit("error", err);
            });
            socket.on("close", this.onSocketClose.bind(this));
            socket.on("data", this.onData.bind(this));
            this._ee.emit("connection");
        });
        server.on("close", () => {
            this._ee.emit("close");
        });
    }
    async initializeClient(socket) {
        this._tcp = socket;
        return new Promise((resolve, reject) => {
            this._send = this.validSend.bind(this);
            this._recv = this.validRecv.bind(this);
            socket.on("connect", () => {
                this._scanner.resetBuffer.call(this._scanner);
                this._ee.emit("connect");
                resolve();
            });
            socket.on("error", err => {
                this._ee.emit("error", err);
                reject(err);
            });
            socket.on("close", this.onSocketClose.bind(this));
            socket.on("data", this.onData.bind(this));
        });
    }
    async cleanupSocket() {
        return new Promise(resolve => {
            if (this._tcp) {
                this._tcp.end(resolve);
            }
            else
                resolve();
        });
    }
    async disconnect() {
        return this.cleanupSocket();
    }
    get socketWritable() {
        return !!this._tcp?.writable;
    }
    async send(m) {
        return this._send(m);
    }
    async recv(timeout = 5000) {
        const _timer = new timer_1.Timer;
        if (timeout > 0)
            _timer.start(timeout);
        let msg = await Promise.race([this._recv(), _timer.watch()]);
        _timer.cancel();
        return msg;
    }
    async transact(m, timeout = 5000) {
        let rsp = null;
        const resName = m.getResponseName();
        await this._lock.acquire(); // prevent other transactions
        let recvPromise = this.recv(timeout);
        await this.send(m);
        if (resName) {
            while (true) {
                try {
                    rsp = await recvPromise;
                }
                catch (e) {
                    this._lock.release();
                    throw e;
                }
                // check type
                if (rsp.getName() === resName)
                    break;
            }
        }
        this._lock.release(); // allow transactions
        return rsp;
    }
}
exports.LLRPNet = LLRPNet;
//# sourceMappingURL=base.js.map