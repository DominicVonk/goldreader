"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LLRPMessage = void 0;
const parameter_1 = require("./parameter");
const element_1 = require("./element");
const buffer_1 = require("../buffer/buffer");
const header_1 = require("./header");
const error_1 = require("../base/error");
class LLRPMessage extends element_1.LLRPElement {
    constructor(args) {
        super();
        this.header = new header_1.LLRPMessageHeader;
        if (args) {
            if (args instanceof buffer_1.LLRPBuffer) {
                this.setBuffer(args);
            }
            else {
                // unmarshalHeader
                this.id = args.id ?? LLRPMessage.getId();
                this.type = args.type;
                this.setData(args.data);
                this.unmarshal(); // convert this data to elements
            }
        }
        this.setStartBit(0);
    }
    static getId() {
        return this.idCounter++;
    }
    get id() { return this.header.getMessageId(); }
    set id(v) { this.header.setMessageId(v); }
    get type() { return this.getName(); }
    ;
    set type(v) { this.setType(v); }
    ;
    get responseType() { return this.td.responseType; }
    ;
    createElement(args) {
        return new parameter_1.LLRPParameter(args);
    }
    setTypeByNumber(type) {
        let td = this.tr.getMsgTypeByTypeNum(type);
        if (!td)
            throw new error_1.LLRPError("ERR_LLRP_BAD_TYPENUM", `typeNum not found ${type}`);
        this.setTypeDescriptor(td);
        return this;
    }
    setType(type) {
        super.setType(type);
        this.header.setMessageTypeNum(this.getTypeNum());
        return this;
    }
    assembleHeader() {
        super.assembleHeader();
        this.header.build();
        return this;
    }
    assemble() {
        super.assemble();
        const byteSize = this.getByteSize();
        this.header.setMessageLength(byteSize);
        this.setBuffer(new buffer_1.LLRPBuffer(Buffer.alloc(byteSize)));
        return this;
    }
    decodeHeader() {
        this.header.setStartBit(0);
        this.assembleHeader();
        this.header.decode();
        let version = this.header.getVersion();
        if (version !== header_1.LLRPMessageHeader.version)
            throw new error_1.LLRPError("ERR_LLRP_UNSUPPORTED_VERSION", `unsupported version ${version}`);
        this.setTypeByNumber(this.header.getMessageTypeNum());
        let length = this.header.getMessageLength();
        if (length < 10)
            throw new error_1.LLRPError("ERR_LLRP_INVALID_LENGTH", `invalid message length ${length}`);
        this.setBitSize(length * 8);
        return this;
    }
    toLLRPData() {
        return {
            id: this.id,
            type: this.type,
            data: this.getData()
        };
    }
}
exports.LLRPMessage = LLRPMessage;
LLRPMessage.version = 1;
LLRPMessage.idCounter = 0;
//# sourceMappingURL=message.js.map