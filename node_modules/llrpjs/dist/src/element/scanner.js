"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LLRPScanner = void 0;
const error_1 = require("../base/error");
const buffer_1 = require("../buffer/buffer");
const header_1 = require("./header");
class LLRPScanner {
    constructor() {
        this.scanner = (new header_1.LLRPMessageHeader).build();
    }
    addBuffer(b) {
        if (this.llrpBuf) {
            let oldBuf = this.llrpBuf.getBuffer();
            this.llrpBuf.setBuffer(Buffer.concat([oldBuf, b]));
        }
        else {
            this.llrpBuf = new buffer_1.LLRPBuffer(b);
        }
        return this;
    }
    resetBuffer() {
        this.llrpBuf = null;
        return this;
    }
    getNext() {
        this.scanner.setStartBit(0).setBuffer(this.llrpBuf);
        try {
            this.scanner.decode();
        }
        catch (e) {
            if (e instanceof error_1.LLRPError) {
                if (e.name === "ERR_LLRP_NO_DATA_IN_BUF")
                    return null;
            }
            throw e;
        }
        const version = this.scanner.getVersion();
        if (version != 1)
            throw new error_1.LLRPError("ERR_LLRP_UNSUPPORTED_VERSION", `unsupported version - received: ${version}, supported: ${header_1.LLRPMessageHeader.version}`);
        const msgLength = this.scanner.getMessageLength();
        if (msgLength < 10)
            throw new error_1.LLRPError("ERR_LLRP_INVALID_LENGTH", `invalid message length ${msgLength}`);
        const buffer = this.scanner.getBuffer().getBuffer();
        if (buffer.length < msgLength)
            return null;
        const messageBuf = buffer.slice(0, msgLength);
        this.llrpBuf.setBuffer(buffer.slice(msgLength));
        return messageBuf;
    }
}
exports.LLRPScanner = LLRPScanner;
//# sourceMappingURL=scanner.js.map