"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LLRPParameter = void 0;
const error_1 = require("../base/error");
const buffer_1 = require("../buffer/buffer");
const header_fd_1 = require("./header-fd");
const llrp_1 = require("../field/llrp");
const element_1 = require("./element");
const header_1 = require("./header");
class LLRPParameter extends element_1.LLRPElement {
    constructor(args) {
        super();
        this.header = new header_1.LLRPParameterHeader;
        if (args) {
            if (args instanceof buffer_1.LLRPBuffer) {
                this.setBuffer(args);
            }
            else {
                this.type = args.type;
                this.setData(args.data);
                this.unmarshal();
            }
        }
        this.setStartBit(0);
    }
    get type() { return this.getName(); }
    ;
    set type(v) { this.setType(v); }
    ;
    createElement(args) {
        return new LLRPParameter(args);
    }
    setTypeByNumber(type) {
        let td = this.tr.getParamTypeByTypeNum(type);
        if (!td)
            throw new error_1.LLRPError("ERR_LLRP_BAD_TYPENUM", `typeNum not found ${type}`);
        this.setTypeDescriptor(td);
        return this;
    }
    setType(type) {
        super.setType(type);
        if (this.isTV)
            this.header.setTVTypeNum(this.getTypeNum());
        else
            this.header.setTLVTypeNum(this.getTypeNum());
        return this;
    }
    assembleHeader() {
        super.assembleHeader();
        if (this.isTV) {
            this.header.buildTV();
            this.header.setTVTypeNum(this.getTypeNum());
        }
        else {
            this.header.buildTLV();
            this.header.setTLVTypeNum(this.getTypeNum());
        }
        return this;
    }
    assemble() {
        super.assemble();
        if (!this.isTV)
            this.header.setTLVLength(this.getByteSize());
        if (!this.getBuffer()) // in case we are testing a parameter alone
            this.setBuffer(new buffer_1.LLRPBuffer(Buffer.alloc(this.getByteSize())));
        return this;
    }
    decodeHeader() {
        this.header.setStartBit(this.getStartBit());
        let typeNum = llrp_1.LLRPFieldFactory(header_fd_1.LLRP_TD_TV_TYPENUM).setBuffer(this.getBuffer())
            .setStartBit(this.getStartBit())
            .decode()
            .getValue();
        if (typeNum & 0x80) {
            // TV
            typeNum &= 0x7f;
            this.setTypeByNumber(typeNum);
            this.header.buildTV();
            return this;
        }
        // TLV ? Message ?
        typeNum = llrp_1.LLRPFieldFactory(header_fd_1.LLRP_TD_RSVD_TYPENUM).setBuffer(this.getBuffer())
            .setStartBit(this.getStartBit())
            .decode()
            .getValue();
        this.setTypeByNumber(typeNum & 0x3ff);
        this.header.buildTLV();
        this.header.decode();
        const length = this.header.getTLVLength();
        if (length < 4)
            throw new error_1.LLRPError("ERR_LLRP_INVALID_LENGTH", `invalid parameter length ${length}`);
        this.setBitSize(length * 8);
        return this;
    }
    decodeFields() {
        super.decodeFields();
        if (this.isTV) {
            let fieldSize = this.fieldList.getBitSize();
            this.setBitSize(this.header.getBitSize() + fieldSize);
        }
        return this;
    }
    toLLRPData() {
        return this.getData();
    }
}
exports.LLRPParameter = LLRPParameter;
//# sourceMappingURL=parameter.js.map