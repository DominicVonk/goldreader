"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LLRPTypeDescriptor = void 0;
const Mixin_1 = require("../bryntum/chronograph/Mixin");
const type_registry_1 = require("../registry/type-registry");
const list_1 = require("../base/list");
const node_1 = require("../base/node");
const error_1 = require("../base/error");
const MaxOfOneRepeat = ["0-1", "1"];
const UnlimitedRepeat = ["0-N", "1-N"];
const RequiredRepeat = ["1", "1-N"];
class LLRPTypeDescriptor extends Mixin_1.Mixin([], (base) => class LLRPTypeDescriptor extends base {
    constructor() {
        super(...arguments);
        this.tr = type_registry_1.TypeRegistry.getInstance();
        this.td = null;
        this.tRefs = {};
        this.pool = {};
    }
    buildTypeReferences() {
        // flatten out choices as well
        this.tRefs = this.td.subTypeRefs.reduce((acc, x) => {
            if (this.isChoice(x)) {
                for (let td of x.choices) {
                    acc[td.name] = x;
                }
            }
            acc[x.td.name] = x;
            return acc;
        }, {});
        return this;
    }
    // pool tools
    addSubType(name, v) {
        if (this.pool[name]) {
            if (this.pool[name] instanceof node_1.LLRPNode) {
                let foundNode = this.pool[name];
                let newList = [];
                newList.push(foundNode);
                newList.push(v);
                this.pool[name] = newList;
            }
            else {
                this.pool[name].push(v);
            }
        }
        else
            this.pool[name] = v;
        return this;
    }
    getSubType(name) {
        return this.pool[name] || null;
    }
    removeSubType(name) {
        return delete this.pool[name];
    }
    setTypeDescriptor(td) {
        this.td = td;
        this.buildTypeReferences();
        return this;
    }
    setType(type) {
        let td = this.tr.getTypeDescByName(type);
        if (!td)
            throw new error_1.LLRPError("ERR_LLRP_BAD_TYPENUM", `type not found ${type}`);
        this.setTypeDescriptor(td);
        return this;
    }
    isAllowedIn(ref) {
        if (typeof ref === 'string') {
            ref = this.getSubTypeRefByName(ref);
        }
        if (!ref)
            return false;
        const name = ref.td.name;
        const repeat = ref.repeat;
        let count = 0;
        if (this.isChoice(ref)) {
            const paramNameList = ref.choices.map(td => td.name) || [];
            for (let key in this.pool) {
                if (paramNameList.includes(key)) {
                    let subType = this.getSubType(key);
                    if (!subType)
                        continue;
                    if (subType instanceof list_1.LLRPList) {
                        count += subType.length;
                    }
                    else
                        count += 1;
                }
            }
        }
        else {
            let subType = this.getSubType(name);
            if (subType) {
                if (subType instanceof list_1.LLRPList)
                    count += subType.length;
                else
                    count += 1;
            }
        }
        return MaxOfOneRepeat.includes(repeat) && count < 1 ? true
            : UnlimitedRepeat.includes(repeat) ? true : false;
    }
    isRequired(arg) {
        let ref;
        if (typeof arg === 'string')
            ref = this.getSubTypeRefByName(arg);
        else
            ref = arg;
        return RequiredRepeat.includes(ref.repeat);
    }
    isUnlimitedRepeat(ref) {
        return UnlimitedRepeat.includes(ref.repeat);
    }
    isMaxOfOneRepeat(ref) {
        return MaxOfOneRepeat.includes(ref.repeat);
    }
    isReferenced(name, ref) {
        if (this.isChoice(ref)) {
            return !!ref.choices.filter(td => td.name === name)[0];
        }
        return name === ref.td.name;
    }
    isChoice(ref) {
        return !!ref.choices?.length;
    }
    getName() {
        return this.td?.name || "Unknown";
    }
    getTypeNum() {
        return this.td?.typeNum || -1;
    }
    getResponseTypeDescriptor() {
        return this.td?.responseType || null;
    }
    getFieldDescriptors() {
        return this.td?.fieldDescriptors || [];
    }
    getSubTypeReferences() {
        return this.td?.subTypeRefs || [];
    }
    getSubTypeRefByName(name) {
        return this.tRefs[name] || null;
    }
    get isMessage() {
        return this.td?.isMessage || false;
    }
    get isTV() {
        if (this.isMessage)
            return false;
        return this.td?.typeNum < 128 && this.td?.typeNum > 0;
    }
}) {
}
exports.LLRPTypeDescriptor = LLRPTypeDescriptor;
//# sourceMappingURL=type-descriptor.js.map