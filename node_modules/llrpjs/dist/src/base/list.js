"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LLRPList = void 0;
const Mixin_1 = require("../bryntum/chronograph/Mixin");
const bound_1 = require("../buffer/bound");
const error_1 = require("./error");
class LLRPList extends Mixin_1.MixinAny([bound_1.LLRPBound], (base) => class LLRPList extends base {
    constructor() {
        super(...arguments);
        this.first = null;
        this.last = null;
        this.length = 0;
    }
    get isEmpty() {
        return !this.first;
    }
    _push(v) {
        if (!v)
            return null;
        if (this.isEmpty) {
            v.prev = null;
            v.next = null;
            this.first = this.last = v;
        }
        else {
            v.prev = this.last;
            this.last.next = v;
            this.last = v;
        }
        v.next = null;
        return ++this.length;
    }
    _pop() {
        if (this.isEmpty)
            return null;
        let popped = this.last;
        this.last = this.last.prev;
        if (this.last) {
            this.last.next = null;
            popped.prev = null;
        }
        else {
            this.first = null;
        }
        this.length--;
        return popped;
    }
    _concat(v) {
        if (this.first && v.first) {
            this.last = v.last;
        }
        else if (!this.first) {
            this.first = v.first;
            this.last = v.last;
        }
        this.length += v.length;
        return this;
    }
    setStartBit(bit) {
        super.setStartBit(bit);
        for (let i = this.first; !!i; i = i.next) {
            if (i.prev)
                i.setStartBit(i.prev.getEndBit() + 1);
            else
                i.setStartBit(this.getStartBit());
        }
        return this;
    }
    /**
     * updates all nodes' starting points, buffer pointers, and this list's total size
     */
    setBuffer(b) {
        this.buffer = b;
        for (let i = this.first; !!i; i = i.next) {
            i.setBuffer(b);
            if (i.prev)
                i.setStartBit(i.prev.getEndBit() + 1);
            else
                i.setStartBit(this.getStartBit());
        }
        return this;
    }
    getEndBit() {
        if (this.isEmpty) {
            return this.getStartBit() - 1;
        }
        return this.last.getEndBit();
    }
    getBitSize() {
        return this.getEndBit() - this.getStartBit() + 1;
    }
    getEndByte() {
        return this.getEndBit() >> 3;
    }
    getByteSize() {
        return this.getEndByte() - this.getStartByte() + 1;
    }
    setBitSize(bit) {
        throw new error_1.LLRPError("ERR_LLRP_INTERNAL", `setBitSize is not allowed for list`);
    }
    getBuffer() {
        return this.buffer;
    }
    // List ops
    getFirst() {
        return this.first;
    }
    getLast() {
        return this.last;
    }
    push(v) {
        v.setBuffer(this.buffer);
        if (this.isEmpty) {
            v.setStartBit(this.getStartBit());
        }
        else {
            v.setStartBit(this.last.getEndBit() + 1);
        }
        return this._push(v);
    }
    pop() {
        let popped = this._pop();
        popped.setBuffer(null);
        return popped;
    }
    clear() {
        this.first = null;
        this.last = null;
        this.length = 0;
        return this;
    }
    // Encode/decode
    encode() {
        for (let i = this.first; !!i; i = i.next) {
            i.encode();
        }
        return this;
    }
    decode() {
        for (let i = this.first; !!i; i = i.next) {
            i.decode();
            if (i.next) {
                i.next.setStartBit(i.getEndBit() + 1);
            }
        }
        return this;
    }
    *[Symbol.iterator]() {
        let p = this.first;
        while (p) {
            let y = p;
            p = p.next;
            yield y;
        }
    }
}) {
}
exports.LLRPList = LLRPList;
;
//# sourceMappingURL=list.js.map