"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeRegistry = void 0;
const error_1 = require("../base/error");
class TypeRegistry {
    constructor() {
        this.coreTypeByName = {};
        this.customTypeByName = {};
        this.coreMsgByTypeNum = {};
        this.customMsgByTypeNum = {};
        this.coreParamByTypeNum = {};
        this.customParamByTypeNum = {};
        this.coreTypeDefinitions = {};
        this.customTypeDefinitions = {};
        this.vendorIdList = [];
    } // constructor needs to be private to force consumers to use it as a singlton
    reset() {
        this.coreTypeByName
            = this.coreMsgByTypeNum
                = this.customTypeByName
                    = this.customMsgByTypeNum
                        = {};
        this.vendorIdList = [];
    }
    getTypeDefinitionByName(name) {
        return this.coreTypeDefinitions[name] || null;
    }
    convertToTypeDescriptor(def) {
        let td = {
            ...def,
            responseType: undefined,
            subTypeRefs: []
        };
        if (def.responseType) {
            let responseType = this.getTypeDefinitionByName(def.responseType);
            if (!responseType)
                throw new error_1.LLRPError("ERR_LLRP_INTERNAL", `no response definition found for message ${def.name}`);
            td.responseType = responseType;
        }
        for (let tRefDef of def.subTypeRefs) {
            let tRef = {
                ...tRefDef,
                td: {},
                choices: undefined
            };
            let subTd = this.getTypeDefinitionByName(tRefDef.td);
            if (!subTd)
                throw new error_1.LLRPError("ERR_LLRP_INTERNAL", `no type definition found for sub-ref ${tRefDef.td}`);
            tRef.td = subTd;
            if (tRefDef.choices) {
                tRef['choices'] = [];
                for (let choiceName of tRefDef.choices) {
                    let choiceTd = this.getTypeDefinitionByName(choiceName);
                    if (!choiceTd)
                        throw new error_1.LLRPError("ERR_LLRP_INTERNAL", `no type definition found for choice ${choiceName}`);
                    tRef.choices.push(choiceTd);
                }
            }
            else {
                tRef['choices'] = undefined;
            }
            td.subTypeRefs.push(tRef);
        }
        return td;
    }
    enrollCoreDef(tDef) {
        this.coreTypeDefinitions[tDef.name] = tDef;
        return this;
    }
    enrollCustomDef(tDef) {
        if (tDef.typeNum > 1023 || tDef.typeNum < 0)
            throw new error_1.LLRPError("ERR_LLRP_INTERNAL", `bad definition typeNum ${tDef.typeNum}`);
        let vendorId = tDef.vendorDescriptor.vendorID;
        if (!this.customTypeDefinitions[vendorId]) {
            this.customTypeDefinitions[vendorId] = {};
        }
        this.customTypeDefinitions[vendorId][tDef.name] = tDef;
        this.vendorIdList.push(vendorId);
        return this;
    }
    enrollCore(td) {
        if (td.typeNum < 0)
            return this;
        this.coreTypeByName[td.name] = td;
        if (td.isMessage)
            this.coreMsgByTypeNum[td.typeNum] = td;
        else
            this.coreParamByTypeNum[td.typeNum] = td;
        return this;
    }
    enrollCustom(td) {
        if (td.typeNum < 0)
            return this;
        let vendorId = td.vendorDescriptor.vendorID;
        if (!this.customTypeByName[vendorId]) {
            this.customTypeByName[vendorId] = {};
        }
        this.customTypeByName[vendorId][td.name] = td;
        if (td.isMessage) {
            if (!this.customMsgByTypeNum[vendorId])
                this.customMsgByTypeNum[vendorId] = {};
            this.customMsgByTypeNum[vendorId][td.typeNum] = td;
        }
        else {
            if (!this.customParamByTypeNum[vendorId])
                this.customParamByTypeNum[vendorId] = {};
            this.customParamByTypeNum[vendorId][td.typeNum] = td;
        }
        return this;
    }
    static getInstance() {
        if (!TypeRegistry.instance) {
            TypeRegistry.instance = new TypeRegistry();
        }
        return TypeRegistry.instance;
    }
    build() {
        this.reset();
        for (let key in this.coreTypeDefinitions) {
            let tDef = this.coreTypeDefinitions[key];
            let td = this.convertToTypeDescriptor(tDef);
            this.enrollCore(td);
        }
        for (let vendorId of this.vendorIdList) {
            for (let key in this.customTypeDefinitions) {
                let tDef = this.customTypeDefinitions[vendorId][key];
                let td = this.convertToTypeDescriptor(tDef);
                this.enrollCustom(td);
            }
        }
        return this;
    }
    enrollCoreDefinitions(Def) {
        for (let key in Def) {
            let tDef = Def[key];
            this.enrollCoreDef(tDef);
        }
        return this;
    }
    enrollCustomDefinitions(Def) {
        for (let key in Def) {
            let tDef = Def[key];
            this.enrollCustomDef(tDef);
        }
        return this;
    }
    getMsgTypeByTypeNum(typeNum) {
        return this.coreMsgByTypeNum[typeNum] || null;
    }
    getParamTypeByTypeNum(typeNum) {
        return this.coreParamByTypeNum[typeNum] || null;
    }
    getTypeDescByName(name) {
        return this.coreTypeByName[name] || null;
    }
    /** custom elements */
    getCustomTypeDescByTypeNum(vendorID, typeNum) {
        return this.customMsgByTypeNum[vendorID]?.[typeNum] || null;
    }
    getCustomTypeDescByName(vendorID, name) {
        return this.customTypeByName[vendorID]?.[name] || null;
    }
}
exports.TypeRegistry = TypeRegistry;
//# sourceMappingURL=type-registry.js.map