"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitOps = void 0;
/** Buffer ops */
class BitOps {
    constructor(buffer) {
        this.buffer = buffer;
    }
    /** big-endian bit ops */
    readBit(offset = 0, bit = 0) {
        return (this.buffer[offset] >> (7 - (bit & 7))) & 1;
    }
    writeBit(value, offset = 0, bit = 0) {
        value = value ? 1 : 0;
        if (this.readBit(offset, bit) === value)
            return 0;
        this.buffer[offset] ^= 1 << (7 - (bit & 7));
        return 1;
    }
    readBits(offset, bit, n) {
        return (this.buffer[offset] & (0xff >> bit)) >> (8 - bit - n);
    }
    writeBits(value, offset, bit, n) {
        // Do we need this?!
        return 0;
    }
    readNMsbBE(offset = 0, n = 0) {
        return this.buffer[offset] >> (8 - n);
    }
    readNLsbBE(offset = 0, n = 0) {
        return this.buffer[offset] & (0xff >> (8 - n));
    }
    writeNMsbBE(value, offset = 0, n = 0) {
        /** 2x buff I/O ops */
        value = 0xff & (value << (8 - n));
        let mask = 0xff >> n;
        this.buffer[offset] = (value & ~mask) | (this.buffer[offset] & mask);
        return 1;
    }
    writeNLsbBE(value, offset = 0, n = 0) {
        let mask = 0xff >> (8 - n);
        this.buffer[offset] = (value & mask) | (this.buffer[offset] & ~mask);
        return 1;
    }
}
exports.BitOps = BitOps;
//# sourceMappingURL=bitops.js.map