"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LLRPBuffer = void 0;
const bitops_1 = require("./bitops");
class LLRPBuffer {
    constructor(buffer) {
        this._byte = 0; // index (offset)
        this._bit = 0; // index of bit in the current byte address MSB(0)/LSB(7)
        this.setBuffer(buffer);
    }
    get bit() {
        return this._byte * 8 + this._bit;
    }
    set bit(v) {
        this._bit = v & 7;
        this._byte = v >> 3;
    }
    get byte() {
        return this._byte;
    }
    set byte(v) {
        this._byte = v;
    }
    hasData(bitSize) {
        const lastBitIndex = this._buffer.length * 8 - 1;
        const availableSize = lastBitIndex - this.bit + 1;
        return availableSize >= bitSize;
    }
    setBuffer(buffer) {
        this._buffer = buffer;
        this._bitOps = new bitops_1.BitOps(buffer);
        return this;
    }
    getBuffer() {
        return this._buffer;
    }
    setBitIndex(startBit) {
        this.bit = startBit;
    }
    getBitIndex() {
        return this.bit;
    }
    getByteIndex() {
        return this.byte;
    }
    // LLRPField is BE protocol
    readBit() {
        return this._bitOps.readBit(this.byte, this.bit++);
    }
    writeBit(v) {
        return this._bitOps.writeBit(v ? 1 : 0, this.byte, this.bit++);
    }
    readBits(n) {
        let result = this._bitOps.readBits(this.byte, this.bit, n);
        this.bit += n;
        return result;
    }
    writeBits(value, n) {
        let result = this._bitOps.writeBits(value, this.byte, this.bit, n);
        this.bit += n;
        return result;
    }
    readNMsb(n) {
        let result = this._bitOps.readNMsbBE(this.byte, n);
        this.bit += n;
        return result;
    }
    writeNMsb(v, n) {
        let result = this._bitOps.writeNMsbBE(v, this.byte, n);
        this.bit += n;
        return result;
    }
    readUInt8() {
        return this._buffer.readUInt8(this.byte++);
    }
    writeUInt8(v) {
        return this._buffer.writeUInt8(v, this.byte++);
    }
    readInt8() {
        return this._buffer.readInt8(this.byte++);
    }
    writeInt8(v) {
        return this._buffer.writeInt8(v, this.byte++);
    }
    readUInt16() {
        let n = 2;
        let res = this._buffer.readUInt16BE(this.byte);
        this.byte += n;
        return res;
    }
    writeUInt16(v) {
        let n = 2;
        let res = this._buffer.writeUInt16BE(v, this.byte);
        this.byte += n;
        return res;
    }
    readInt16() {
        let n = 2;
        let res = this._buffer.readInt16BE(this.byte);
        this.byte += n;
        return res;
    }
    writeInt16(v) {
        let n = 2;
        let res = this._buffer.writeInt16BE(v, this.byte);
        this.byte += n;
        return res;
    }
    readUInt32() {
        let n = 4;
        let res = this._buffer.readUInt32BE(this.byte);
        this.byte += n;
        return res;
    }
    writeUInt32(v) {
        let n = 4;
        let res = this._buffer.writeUInt32BE(v, this.byte);
        this.byte += n;
        return res;
    }
    readInt32() {
        let n = 4;
        let res = this._buffer.readInt32BE(this.byte);
        this.byte += n;
        return res;
    }
    writeInt32(v) {
        let n = 4;
        let res = this._buffer.writeInt32BE(v, this.byte);
        this.byte += n;
        return res;
    }
    readUInt64() {
        let n = 8;
        let res = this._buffer.readBigUInt64BE(this.byte);
        this.byte += n;
        return res;
    }
    writeUInt64(v) {
        let n = 8;
        let res = this._buffer.writeBigUInt64BE(v, this.byte);
        this.byte += n;
        return res;
    }
    readInt64() {
        let n = 8;
        let res = this._buffer.readBigInt64BE(this.byte);
        this.byte += n;
        return res;
    }
    writeInt64(v) {
        let n = 8;
        let res = this._buffer.writeBigInt64BE(v, this.byte);
        this.byte += n;
        return res;
    }
    readUTF8(n) {
        let res = this._buffer.slice(this.byte, this.byte + n).toString("utf-8");
        this.byte += n;
        return res;
    }
    writeUTF8(v) {
        let n = v.length;
        this._buffer.write(v, this.byte, "utf-8");
        this.byte += n;
        return n;
    }
}
exports.LLRPBuffer = LLRPBuffer;
//# sourceMappingURL=buffer.js.map