"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LLRPTypedParameter = void 0;
const parameter_1 = require("../element/parameter");
const parameter_2 = require("../proxy/parameter");
const class_registry_1 = require("../registry/class-registry");
class LLRPTypedParameter extends parameter_2.LLRPProxyParameter {
    constructor() {
        super(...arguments);
        this.CR = class_registry_1.LLRPClassRegistry.getInstance();
    }
    static ofDef(Def) {
        return class LLRPTypedParameter extends this {
            constructor() {
                super(...arguments);
                this.Def = Def;
                this.CR = class_registry_1.LLRPClassRegistry.getInstance(Def);
            }
        };
    }
    static ofType(Def, Name) {
        class _LLRPTypedParameter extends this {
            constructor(args) {
                if (args instanceof parameter_1.LLRPParameter || args instanceof Buffer) {
                    super(args);
                }
                else
                    super({ data: {}, ...args, ...{ type: Name } });
            }
        }
        _LLRPTypedParameter._def = Def;
        const td = Def[Name];
        // Fields
        for (let fd of td.fieldDescriptors) {
            if (fd.type === "reserved")
                continue;
            _LLRPTypedParameter.prototype[`set${fd.name}`] = function (v) {
                this.setField(fd.name, v);
                return this;
            };
            _LLRPTypedParameter.prototype[`get${fd.name}`] = function () {
                return this.getField(fd.name);
            };
        }
        // Sub-parameters
        for (let tRef of td.subTypeRefs) {
            const { td: name, repeat } = tRef;
            if (repeat === "0-1" || repeat === "1") {
                _LLRPTypedParameter.prototype[`set${name}`] = function (p) {
                    this.setSubParameter(name, p);
                    return this;
                };
            }
            else {
                _LLRPTypedParameter.prototype[`add${name}`] = function (p) {
                    this.addSubParameter(name, p);
                    return this;
                };
            }
            _LLRPTypedParameter.prototype[`get${name}`] = function () {
                const subP = this.getSubParameter(name);
                if (!subP)
                    return null;
                if (Array.isArray(subP)) {
                    return subP;
                }
                return subP;
            };
        }
        return _LLRPTypedParameter;
    }
    setField(name, v) {
        this.origin.setField(name, v);
        return this;
    }
    getField(name) {
        return this.origin.getField(name);
    }
    addSubParameter(name, p) {
        this.origin.addSubElement(name, p.origin);
        return this;
    }
    setSubParameter(name, p) {
        this.origin.setSubElement(name, p.origin);
        return this;
    }
    getSubParameter(name) {
        const originP = this.origin.getSubElement(name);
        if (!originP)
            return null;
        // wrap it
        if (Array.isArray(originP)) {
            return originP.map(p => {
                let TypedClass = this.CR.getCoreParameterClass(p.getName());
                if (!TypedClass) {
                    TypedClass = parameter_2.LLRPProxyParameter;
                }
                return new TypedClass(originP);
            });
        }
        let TypedClass = this.CR.getCoreParameterClass(originP.getName());
        if (!TypedClass) {
            TypedClass = parameter_2.LLRPProxyParameter;
        }
        return new TypedClass(originP);
    }
    setParamType(v) {
        this.origin.type = v;
        return this;
    }
    getParamType() {
        return this.origin.type;
    }
    setParamData(v) {
        this.origin.setData(v);
        return this;
    }
    getParamData() {
        return this.origin.getData();
    }
}
exports.LLRPTypedParameter = LLRPTypedParameter;
//# sourceMappingURL=parameter.js.map