"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LLRPTypedMessage = void 0;
const message_1 = require("../element/message");
const parameter_1 = require("../proxy/parameter");
const class_registry_1 = require("../registry/class-registry");
const message_2 = require("../proxy/message");
class LLRPTypedMessage extends message_2.LLRPProxyMessage {
    constructor() {
        super(...arguments);
        this.CR = class_registry_1.LLRPClassRegistry.getInstance();
    }
    static ofDef(Def) {
        return class LLRPTypedMessage extends this {
            constructor() {
                super(...arguments);
                this.Def = Def;
                this.CR = class_registry_1.LLRPClassRegistry.getInstance(Def);
            }
        };
    }
    static ofType(Def, Name) {
        class _LLRPTypedMessage extends this {
            constructor(args) {
                if (args instanceof message_1.LLRPMessage || args instanceof Buffer) {
                    super(args);
                }
                else {
                    super({ data: {}, ...args, ...{ type: Name } });
                }
            }
        }
        _LLRPTypedMessage._def = Def;
        const td = Def[Name];
        // Fields
        for (let fd of td.fieldDescriptors) {
            if (fd.type === "reserved")
                continue;
            _LLRPTypedMessage.prototype[`set${fd.name}`] = function (v) {
                this.setField(fd.name, v);
                return this;
            };
            _LLRPTypedMessage.prototype[`get${fd.name}`] = function () {
                return this.getField(fd.name);
            };
        }
        // Sub-parameters
        for (let tRef of td.subTypeRefs) {
            const { td: name, repeat } = tRef;
            if (repeat === "0-1" || repeat === "1") {
                _LLRPTypedMessage.prototype[`set${name}`] = function (p) {
                    this.setSubParameter(name, p);
                    return this;
                };
            }
            else {
                _LLRPTypedMessage.prototype[`add${name}`] = function (p) {
                    this.addSubParameter(name, p);
                    return this;
                };
            }
            _LLRPTypedMessage.prototype[`get${name}`] = function () {
                const subP = this.getSubParameter(name);
                if (!subP)
                    return null;
                if (Array.isArray(subP)) {
                    return subP;
                }
                return subP;
            };
        }
        return _LLRPTypedMessage;
    }
    get hasResponse() {
        return !!this.origin.responseType;
    }
    getName() {
        return super.getName();
    }
    getResponseName() {
        return super.getResponseName();
    }
    setField(name, v) {
        this.origin.setField(name, v);
        return this;
    }
    getField(name) {
        return this.origin.getField(name);
    }
    addSubParameter(name, p) {
        this.origin.addSubElement(name, p.origin);
        return this;
    }
    setSubParameter(name, p) {
        this.origin.setSubElement(name, p.origin);
        return this;
    }
    getSubParameter(name) {
        // this is to allow typed returns
        let TypedClass = this.CR.getCoreParameterClass(name);
        if (!TypedClass) {
            TypedClass = parameter_1.LLRPProxyParameter;
        }
        const originP = this.origin.getSubElement(name);
        if (!originP)
            return null;
        // wrap it
        if (Array.isArray(originP)) {
            return originP.map(p => new TypedClass(p));
        }
        return new TypedClass(originP);
    }
    setMessageType(v) {
        return super.setMessageType(v);
    }
}
exports.LLRPTypedMessage = LLRPTypedMessage;
//# sourceMappingURL=message.js.map