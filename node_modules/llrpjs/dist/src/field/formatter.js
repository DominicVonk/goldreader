"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LLRPFormatterParser = void 0;
const Mixin_1 = require("../bryntum/chronograph/Mixin");
const descriptor_1 = require("./descriptor");
const error_1 = require("../base/error");
const ISO8601_REGEX_MILLI = /(?<=\.)\d{3}(?=Z)/;
const ISO8601_REGEX_MICRO = /(?<=\.)\d{6}(?=Z)/;
class LLRPFormatterParser extends Mixin_1.Mixin([descriptor_1.LLRPFieldDescriptor], (base) => { var _a; return _a = class LLRPFormatterParser extends base {
        static formatIso8601Microseconds(microseconds) {
            const date = (new Date(Number(microseconds / 1000n))).toISOString();
            const residue = (microseconds % 1000000n).toString().padStart(6, "0");
            return date.replace(ISO8601_REGEX_MILLI, residue);
        }
        static parseIso8601Microseconds(timestamp) {
            // seconds
            if (timestamp instanceof Date)
                timestamp = timestamp.toJSON();
            let time = Math.floor(Date.parse(timestamp) / 1000);
            let microseconds = parseInt(timestamp.match(ISO8601_REGEX_MICRO)?.toString() || "", 10);
            if (isNaN(microseconds))
                microseconds = parseInt(timestamp.match(ISO8601_REGEX_MILLI)?.toString() || "", 10) * 1000;
            if (isNaN(microseconds))
                throw new error_1.LLRPError("ERR_LLRP_BAD_FORMAT", `cannot parse microseconds ${timestamp}`);
            return BigInt(time * 1000000 + microseconds);
        }
        static enableFullPrecision() {
            LLRPFormatterParser.fullPrecision = true;
        }
        static disableFullPrecision() {
            LLRPFormatterParser.fullPrecision = false;
        }
        // Formatters
        static formatNormal(value) {
            return value;
        }
        static formatDec(value) {
            return value.toString(10);
        }
        static formatDecVector(value) {
            return value.map(x => LLRPFormatterParser.formatDec(x)).join(' ');
        }
        static formatHex(value, bitWidth) {
            return value.toString(16).padStart(bitWidth / 4, "0").toUpperCase();
        }
        static formatHexVector(value, bitWidth) {
            return value.map(x => LLRPFormatterParser.formatHex(x, bitWidth)).join('');
        }
        static formatDateTime(value) {
            return LLRPFormatterParser.fullPrecision ?
                LLRPFormatterParser.formatIso8601Microseconds(value)
                : (new Date(Number(value) / 1000)).toJSON();
        }
        static formatUTF8(value) {
            return value;
        }
        // Parsers
        static parseNormal(v) {
            return v;
        }
        static parseDec(v) {
            return parseInt(v, 10);
        }
        static parseDecVector(v) {
            return v.split(' ').map(() => LLRPFormatterParser.parseDec(v));
        }
        static parseHex(v) {
            return parseInt(v, 16);
        }
        static parseHexVector(v, bitWidth) {
            let n = bitWidth / 4;
            v = v.trim().split('').reduce((acc, x, i) => (i % n == 0) && (i != 0) ? `${acc},${x}` : `${acc}${x}`, '');
            return v.length ? v.split(',').map(x => parseInt(x.padEnd(2, "0"), 16)) : [];
        }
        static parseDateTime(v) {
            return LLRPFormatterParser.fullPrecision ? LLRPFormatterParser.parseIso8601Microseconds(v)
                : BigInt(new Date(v)) * 1000n;
        }
        static parseUTF8(value) {
            return value;
        }
        /** methods */
        getFormatted(v) {
            let res;
            if (this.isNormalFormattable)
                res = LLRPFormatterParser.formatNormal(v); // void
            else if (this.isDecFormattable)
                res = (this.isVectorType ?
                    LLRPFormatterParser.formatDecVector(v)
                    : LLRPFormatterParser.formatDec(v));
            else if (this.isHexFormattable)
                res = (this.isVectorType ?
                    LLRPFormatterParser.formatHexVector(v, this.bitWidth)
                    : LLRPFormatterParser.formatHex(v, this.bitWidth));
            else if (this.isUtf8Formattable)
                res = LLRPFormatterParser.formatUTF8(v);
            else if (this.isDateFormattable)
                res = LLRPFormatterParser.formatDateTime(v);
            return res;
        }
        getParsed(v) {
            let res;
            if (this.isNormalFormattable)
                res = LLRPFormatterParser.parseNormal(v);
            else if (this.isDecFormattable)
                res = this.isVectorType ?
                    LLRPFormatterParser.parseDec(v)
                    : LLRPFormatterParser.parseDecVector(v);
            else if (this.isHexFormattable)
                res = this.isVectorType ?
                    LLRPFormatterParser.parseHexVector(v, this.bitWidth)
                    : LLRPFormatterParser.parseHex(v);
            else if (this.isUtf8Formattable)
                res = LLRPFormatterParser.parseUTF8(v);
            else if (this.isDateFormattable)
                res = LLRPFormatterParser.parseDateTime(v);
            return res;
        }
    },
    _a.fullPrecision = true,
    _a; }) {
}
exports.LLRPFormatterParser = LLRPFormatterParser;
//# sourceMappingURL=formatter.js.map