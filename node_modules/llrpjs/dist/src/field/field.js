"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LLRPFieldInstanceType = exports.LLRPField = void 0;
const Mixin_1 = require("../bryntum/chronograph/Mixin");
const enumerator_1 = require("./enumerator");
const formatter_1 = require("./formatter");
const node_1 = require("../base/node");
const data_1 = require("./data");
class LLRPField extends Mixin_1.MixinAny([data_1.LLRPFieldData, formatter_1.LLRPFormatterParser, enumerator_1.LLRPEnumerator, node_1.LLRPNode], (base) => class LLRPField extends base {
    isEVFormattable(v) {
        if (this.isUtf8Formattable)
            return true;
        if (!this.isUnsigned)
            return false;
        if (this.isBigInt)
            return this.isDateFormattable && (typeof v === 'string' || v instanceof Date);
        return typeof v === 'string' && !this.isNormalFormattable;
    }
    isEVEnumerable(v) {
        if (!this.isUnsigned)
            return false;
        if (Array.isArray(v))
            return v.every(x => typeof x === 'string') && this.isEnumerable;
        return typeof v === 'string' && this.isEnumerable;
    }
    setValue(v) {
        let value;
        if (this.isEVFormattable(v)) {
            value = this.getParsed(v);
        }
        else if (this.isEVEnumerable(v)) {
            value = this.getEnumValue(v);
        }
        else {
            if (this.isBigInt)
                value = BigInt(v); // in case data is coming from JSON (to avoid bigint coercion into a number)
            else
                value = v;
        }
        this.setRawValue(value);
        this.updateBitSize(); // update size in case of vectors and strings
        return this;
    }
    getValue() {
        let value;
        if (this.isEnumerable) {
            value = this.getEnumName(this.getRawValue());
        }
        else {
            value = this.getFormatted(this.getRawValue());
        }
        return value;
    }
    updateBitSize() {
        if (this.isType(["u96", "bytesToEnd"])) {
            // they don't have count field
            this.setBitSize(this.bitWidth * this.rValue.length);
        }
        else if (this.isVectorType || this.isString) {
            // other vectors
            this.setBitSize(16 + this.bitWidth * this.rValue.length);
        }
        else {
            this.setBitSize(this.bitWidth);
        }
        return this;
    }
    setDescriptor(fd) {
        super.setDescriptor(fd);
        this.updateBitSize();
        return this;
    }
    setDefault(type) {
        this.setDefaultDescriptor();
        this.setType(type);
        this.setStartBit(0); // default buf start
        this.setDefaultRawValue();
        this.updateBitSize();
        return this;
    }
}) {
    static ofType(type) {
        return class _LLRPField extends LLRPField {
            constructor(...args) {
                super(...args);
                this.setDefault(type);
            }
        };
    }
}
exports.LLRPField = LLRPField;
exports.LLRPFieldInstanceType = LLRPField;
//# sourceMappingURL=field.js.map